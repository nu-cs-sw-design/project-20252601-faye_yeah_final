@startuml
skinparam classAttributeIconSize 0
hide empty members

package "Domain" {
  enum CardType {
    NOPE
    DEFUSE
    ATTACK
    SHUFFLE
    SKIP
    SEE_THE_FUTURE
    CAT_ONE
    CAT_TWO
    CAT_THREE
    CAT_FOUR
    EXPLODING_KITTEN
    STREAKING_KITTEN
    SWAP_TOP_AND_BOTTOM
    GARBAGE_COLLECTION
    CURSE_OF_THE_CAT_BUTT
    ALTER_THE_FUTURE
    CATOMIC_BOMB
    SUPER_SKIP
    MARK
    IMPLODING_KITTEN
    REVERSE
    FERAL_CAT
    TARGETED_ATTACK
    DRAW_FROM_THE_BOTTOM
  }

  class Card {
    - cardType: CardType
    - isMarked: boolean
    - isFacedUp: boolean
    - useEffect: CardEffect
    - drawTrigger: DrawTrigger
    + Card(cardType: CardType, useEffect: CardEffect, drawTrigger: DrawTrigger)
    + getCardType(): CardType
    + executeUseEffect(ctx: EffectContext): EffectResult
    + executeDrawTrigger(ctx: EffectContext): DrawResult
    + markCard(): void
    + setFacedUp(): void
    + checkIfMarked(): boolean
    + checkIfFacedUp(): boolean
  }

  class EffectContext {
    - game: Game
    - currentPlayer: Player
    - allPlayers: Player[]
    - input: InputProvider
    - output: OutputProvider
    - targetPlayer: Player
    + EffectContext(game: Game, currentPlayer: Player, allPlayers: Player[], input: InputProvider, output: OutputProvider)
    + getGame(): Game
    + getDeck(): Deck
    + getCurrentPlayer(): Player
    + getAllPlayers(): Player[]
    + getInput(): InputProvider
    + getOutput(): OutputProvider
    + getTargetPlayer(): Player
    + setTargetPlayer(player: Player): void
  }

  class EffectResult {
    - success: boolean
    - endsTurn: boolean
    - message: String
    - cancelled: boolean
    + isSuccess(): boolean
    + shouldEndTurn(): boolean
    + getMessage(): String
    + isCancelled(): boolean
  }

  class DrawResult {
    - survived: boolean
    - message: String
    - shouldKeepCard: boolean
    + didSurvive(): boolean
    + getMessage(): String
    + shouldKeepCard(): boolean
  }
}

package "Card Effects" {
  interface CardEffect {
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class ShuffleEffect {
    - shuffleStrategy: ShuffleStrategy
    + ShuffleEffect(shuffleStrategy: ShuffleStrategy)
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class SeeTheFutureEffect {
    - cardsToReveal: int
    + SeeTheFutureEffect(cardsToReveal: int)
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class AlterTheFutureEffect {
    - cardsToAlter: int
    + AlterTheFutureEffect(cardsToAlter: int)
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class AttackEffect {
    - targeted: boolean
    + AttackEffect(targeted: boolean)
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class SkipEffect {
    - superSkip: boolean
    + SkipEffect(superSkip: boolean)
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class ReverseEffect {
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class CatomicBombEffect {
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class DrawFromBottomEffect {
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class NoEffect {
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
  }

  class NOPEInterceptor {
    - wrappedEffect: CardEffect
    - requiresNOPECheck: boolean
    + NOPEInterceptor(wrappedEffect: CardEffect, requiresNOPECheck: boolean)
    + execute(ctx: EffectContext): EffectResult
    + canExecute(ctx: EffectContext): boolean
    - checkForNOPE(ctx: EffectContext, playedByPlayer: Player): boolean
    - findNOPECard(player: Player): int
  }
}

package "Draw Triggers" {
  interface DrawTrigger {
    + onDraw(ctx: EffectContext): DrawResult
  }

  class ExplodingKittenTrigger {
    + onDraw(ctx: EffectContext): DrawResult
  }

  class ImplodingKittenTrigger {
    + onDraw(ctx: EffectContext): DrawResult
  }

  class NormalDrawTrigger {
    + onDraw(ctx: EffectContext): DrawResult
  }

  class StreakingKittenTrigger {
    + onDraw(ctx: EffectContext): DrawResult
  }
}

package "Shuffle Strategies" {
  interface ShuffleStrategy {
    + shuffle(deck: Deck): void
  }

  class FisherYatesShuffle {
    + shuffle(deck: Deck): void
  }

  class RiffleShuffle {
    + shuffle(deck: Deck): void
  }

  class PileShuffle {
    - numberOfPiles: int
    + PileShuffle(numberOfPiles: int)
    + shuffle(deck: Deck): void
  }
}

package "Combos" {
  abstract class ComboEffect {
    + execute(ctx: EffectContext): EffectResult
    + getRequiredCardCount(): int
    + acceptsFeralCat(): boolean
  }

  class TwoOfAKindCombo {
    + execute(ctx: EffectContext): EffectResult
    + getRequiredCardCount(): int
    + acceptsFeralCat(): boolean
  }

  class ThreeOfAKindCombo {
    + execute(ctx: EffectContext): EffectResult
    + getRequiredCardCount(): int
    + acceptsFeralCat(): boolean
  }

  class ComboValidator {
    + validateCombo(player: Player, cardType: CardType, count: int, feralCats: int): boolean
    + removeCardsForCombo(player: Player, cardType: CardType, count: int, feralCats: int): void
  }
}

package "Factories" {
  class CardEffectFactory {
    - effectRegistry: Map<CardType, CardEffect>
    - shuffleStrategy: ShuffleStrategy
    + CardEffectFactory()
    + registerEffects(): void
    + getEffect(cardType: CardType): CardEffect
    + getTrigger(cardType: CardType): DrawTrigger
    + hasEffect(cardType: CardType): boolean
    + hasTrigger(cardType: CardType): boolean
  }

  class CardFactory {
    - effectFactory: CardEffectFactory
    + CardFactory(effectFactory: CardEffectFactory)
    + createCard(cardType: CardType): Card
  }
}

package "IO Abstractions" {
  interface InputProvider {
    + readInteger(message: String, min: int, max: int): int
    + readYesNo(message: String): boolean
  }

  interface OutputProvider {
    + display(message: String): void
  }

  class ConsoleInput {
    - scanner: java.util.Scanner
    + ConsoleInput(scanner: java.util.Scanner)
    + readInteger(message: String, min: int, max: int): int
    + readYesNo(message: String): boolean
  }

  class ConsoleOutput {
    + display(message: String): void
  }
}

package "Game Core (stubs)" {
  class Game
  class Deck
  class Player
}

Card --> CardType
Card --> CardEffect
Card --> DrawTrigger

CardEffect <|.. ShuffleEffect
CardEffect <|.. SeeTheFutureEffect
CardEffect <|.. AlterTheFutureEffect
CardEffect <|.. AttackEffect
CardEffect <|.. SkipEffect
CardEffect <|.. ReverseEffect
CardEffect <|.. CatomicBombEffect
CardEffect <|.. DrawFromBottomEffect
CardEffect <|.. NoEffect
CardEffect <|.. NOPEInterceptor

DrawTrigger <|.. ExplodingKittenTrigger
DrawTrigger <|.. ImplodingKittenTrigger
DrawTrigger <|.. NormalDrawTrigger
DrawTrigger <|.. StreakingKittenTrigger

ShuffleStrategy <|.. FisherYatesShuffle
ShuffleStrategy <|.. RiffleShuffle
ShuffleStrategy <|.. PileShuffle
ShuffleEffect --> ShuffleStrategy

ComboEffect <|-- TwoOfAKindCombo
ComboEffect <|-- ThreeOfAKindCombo
ComboValidator ..> ComboEffect

NOPEInterceptor --> CardEffect : wraps
CardEffectFactory --> CardEffect
CardEffectFactory --> DrawTrigger
CardFactory --> Card
CardFactory --> CardEffectFactory

EffectContext --> Game
EffectContext --> Deck
EffectContext --> Player
EffectContext --> InputProvider
EffectContext --> OutputProvider

InputProvider <|.. ConsoleInput
OutputProvider <|.. ConsoleOutput

EffectResult ..> EffectContext
DrawResult ..> EffectContext

ExplodingKittenTrigger ..> DrawResult
ImplodingKittenTrigger ..> DrawResult
NormalDrawTrigger ..> DrawResult
StreakingKittenTrigger ..> DrawResult

Game ..> Deck
Game ..> Player

@enduml

